# Структуры данных в JavaScript

## Array (Массив)

### Основы

- Упорядоченная коллекция элементов с числовыми индексами, начинающимися с 0
- Динамически изменяемый размер
- Может содержать элементы разных типов
- Является объектом специального типа, реализация основана на хеш-таблице

### Методы

- `push()`, `pop()`, `shift()`, `unshift()` - добавление/удаление с начала/конца
- `splice()`, `slice()` - удаление, замена, извлечение элементов
- `map()`, `filter()`, `reduce()`, `forEach()` - функциональные методы обработки
- `find()`, `findIndex()`, `indexOf()` - поиск элементов
- `sort()`, `reverse()` - изменение порядка элементов

### Производительность

- Доступ по индексу: O(1)
- Поиск элемента: O(n)
- Добавление/удаление в конце: O(1)
- Добавление/удаление в начале: O(n) - требует сдвига всех элементов

### Применение

- Для упорядоченных коллекций элементов
- Когда важен порядок элементов
- Для операций над множеством элементов (функциональное программирование)
- Когда нужен быстрый доступ по индексу

## Object (Объект)

### Основы

- Неупорядоченная коллекция пар ключ-значение
- Ключи должны быть строками или символами
- Значения могут быть любых типов
- Реализация на основе хеш-таблицы

### Методы

- `Object.keys()`, `Object.values()`, `Object.entries()` - получение ключей/значений/пар
- `Object.assign()` - копирование свойств
- `Object.freeze()`, `Object.seal()` - защита от изменений
- `hasOwnProperty()` - проверка наличия свойства

### Производительность

- Доступ по ключу: O(1) в среднем
- Добавление/удаление свойств: O(1) в среднем
- Поиск по значению: O(n)

### Применение

- Для хранения данных, доступных по ключу
- Для создания сущностей с именованными свойствами
- В качестве хеш-таблиц для небольших наборов данных
- Для представления структур данных (JSON)

## Map

### Основы

- Коллекция пар ключ-значение с сохранением порядка вставки
- Ключом может быть значение любого типа (включая объекты)
- Предоставляет специализированный API для работы со структурой типа "словарь"

### Методы

- `set()`, `get()`, `has()`, `delete()` - основные операции
- `keys()`, `values()`, `entries()` - итераторы
- `forEach()` - перебор элементов
- `size` - свойство для получения размера

### Производительность

- Доступ/добавление/удаление: O(1) в среднем
- Итерация: O(n)
- Более эффективен для частых добавлений и удалений по сравнению с Object

### Применение

- Когда ключами могут быть не только строки
- Когда важен порядок добавления элементов
- Для создания словарей с произвольными ключами
- Для частых операций добавления/удаления элементов

## Set

### Основы

- Коллекция уникальных значений любого типа
- Сохраняет порядок вставки элементов
- Не может содержать дубликаты
- Предоставляет специализированный API для работы со множествами

### Методы

- `add()`, `has()`, `delete()` - основные операции
- `keys()`, `values()`, `entries()` - итераторы (keys и values идентичны)
- `forEach()` - перебор элементов
- `size` - свойство для получения размера

### Производительность

- Доступ/добавление/удаление: O(1) в среднем
- Проверка наличия элемента: O(1) в среднем
- Быстрее, чем проверка через Array.includes()

### Применение

- Для хранения уникальных значений
- Удаление дубликатов из массива
- Проверка наличия элемента в коллекции
- Реализация математических операций над множествами

## WeakMap

### Основы

- Коллекция пар ключ-значение, где ключи - только объекты
- Не предотвращает сборку мусора для объектов, используемых в качестве ключей
- Не итерируемый (нет методов перебора)
- Не имеет свойства size

### Методы

- `set()`, `get()`, `has()`, `delete()` - основные операции

### Производительность

- Аналогична Map для основных операций
- Меньше накладных расходов на память за счет "слабых" ссылок

### Применение

- Для связывания данных с объектами без влияния на их жизненный цикл
- Для кеширования результатов, связанных с объектами
- Для приватных данных в классах
- Предотвращение утечек памяти при работе с DOM-элементами

## WeakSet

### Основы

- Коллекция уникальных объектов
- Не предотвращает сборку мусора для хранимых объектов
- Не итерируемый (нет методов перебора)
- Не имеет свойства size

### Методы

- `add()`, `has()`, `delete()` - основные операции

### Производительность

- Аналогична Set для основных операций
- Меньше накладных расходов на память за счет "слабых" ссылок

### Применение

- Для маркировки объектов (как флаг)
- Для хранения ссылок на объекты без влияния на их жизненный цикл
- Для отслеживания объектов, которые уже были обработаны

## Сравнение производительности

| Операция | Array   | Object  | Map     | Set     | WeakMap | WeakSet |
| -------- | ------- | ------- | ------- | ------- | ------- | ------- |
| Доступ   | O(1)¹   | O(1)    | O(1)    | —       | O(1)    | —       |
| Поиск    | O(n)    | O(n)²   | O(1)    | O(1)    | O(1)    | O(1)    |
| Вставка  | O(1)³   | O(1)    | O(1)    | O(1)    | O(1)    | O(1)    |
| Удаление | O(n)⁴   | O(1)    | O(1)    | O(1)    | O(1)    | O(1)    |
| Память   | Высокая | Средняя | Высокая | Высокая | Низкая  | Низкая  |

¹ Для доступа по индексу
² Для поиска по значению, O(1) для поиска по ключу
³ O(1) для конца массива, O(n) для начала
⁴ O(1) для конца массива, O(n) для начала и середины

## Рекомендации по выбору структуры данных

- **Array**: когда нужен упорядоченный список с доступом по индексу
- **Object**: для простых пар ключ-значение, где ключи - строки
- **Map**: когда ключи могут быть объектами или нужен точный порядок элементов
- **Set**: для хранения уникальных значений и быстрой проверки наличия
- **WeakMap/WeakSet**: когда нужно связать данные с объектами, не препятствуя их удалению сборщиком мусора

## Особенности и предостережения

- **Object** имеет прототипное наследование, что может вызвать конфликты имен
- **Map** и **Set** более эффективны при большом количестве добавлений/удалений
- **WeakMap** и **WeakSet** не предотвращают утечки памяти, но нельзя перебрать их содержимое
- **Array** может быть неэффективен для операций с началом массива
