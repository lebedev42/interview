# Оптимизация алгоритма: от O(n²) до O(n) с использованием Hash Map

## Задача

Найти два числа в массиве, сумма которых равна заданному целевому значению (target).

**Входные данные:**

- Массив чисел nums: number[]
- Целевое значение target: number

**Выходные данные:**

- Пара индексов [i, j], где nums[i] + nums[j] = target
- null, если такой пары не существует

## Решение 1: Наивный подход O(n²)

```typescript
function twoSumNaive(nums: number[], target: number): [number, number] | null {
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }
  return null;
}
```

### Анализ наивного решения:

1. **Временная сложность:** O(n²)

   - Внешний цикл выполняется n раз
   - Внутренний цикл для каждой итерации внешнего цикла выполняется (n-1), (n-2), ... раз
   - Общее количество операций: n \* (n-1) / 2

2. **Пространственная сложность:** O(1)

   - Используется только константное количество дополнительной памяти

3. **Преимущества:**

   - Простая реализация
   - Не требует дополнительной памяти
   - Понятный код

4. **Недостатки:**
   - Квадратичная сложность
   - Неэффективен на больших наборах данных

## Решение 2: Оптимизированный подход с Hash Map O(n)

```typescript
function twoSumOptimized(
  nums: number[],
  target: number
): [number, number] | null {
  const numMap = new Map<number, number>();

  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];

    if (numMap.has(complement)) {
      return [numMap.get(complement)!, i];
    }

    numMap.set(nums[i], i);
  }

  return null;
}
```

### Анализ оптимизированного решения:

1. **Временная сложность:** O(n)

   - Один проход по массиву
   - Операции с Map (get, set, has) выполняются за O(1)

2. **Пространственная сложность:** O(n)

   - Используется дополнительная память для хранения Map
   - В худшем случае сохраняем все элементы массива

3. **Преимущества:**

   - Линейная сложность
   - Эффективен на больших наборах данных
   - Только один проход по массиву

4. **Недостатки:**
   - Требует дополнительной памяти O(n)
   - Немного сложнее для понимания

## Принцип работы оптимизированного решения:

1. Создаем Map для хранения пар "число -> индекс"
2. Для каждого числа nums[i]:
   - Вычисляем complement = target - nums[i]
   - Если complement уже есть в Map, значит мы нашли пару
   - Если нет, добавляем текущее число и его индекс в Map

## Пример использования:

```typescript
const numbers = [2, 7, 11, 15];
const target = 9;

console.log("Наивное решение O(n²):", twoSumNaive(numbers, target));
// Вывод: [0, 1] (2 + 7 = 9)

console.log("Оптимизированное решение O(n):", twoSumOptimized(numbers, target));
// Вывод: [0, 1] (2 + 7 = 9)
```

## Сравнение производительности:

- На маленьких массивах (n < 100) разница в производительности может быть незаметна
- На больших массивах (n > 1000) оптимизированное решение работает значительно быстрее
- При n = 10000:
  - Наивное решение: ~100,000,000 операций
  - Оптимизированное решение: ~10,000 операций
